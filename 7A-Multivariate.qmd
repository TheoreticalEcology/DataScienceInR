---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
set.seed(42)
```

# Multivariate Statistics

## Unconstrained

```{r}
## PCA
# we use the same dataset of flower characteristics of three species of iris
pairs(iris, col = iris$Species)

head(iris)
pca = prcomp(iris[, 1:4], scale = T) # always set scale = T
# when data is very skewed --> better transform e.g. log

summary(pca)
# standard deviation^2 is variance!!!
# cum prop of PC2 is the variance that is visualized in a biplot


# plot the result
# absolute variance of each component
plot(pca) # see row1 of the summary(pca): (sd)^2 = variance

# rel variance of each component
barplot(summary(pca)$importance[2, ], 
        ylab="proportion of variance explained") # displays % of variance explained by PCs

# Biplot
biplot(pca) # displays PC1 and PC2 AND rotation (vectors) of the different variables AND observations




## distance-based approach: NMDS

library(vegan)
?vegan

# community dataset for plants in dunes (included in vegan package):

data("dune")
str(dune) # display structure of the dataset
?dune
summary(dune) # display summary of the dataset (summary statistics for each variable)

NMDS = metaMDS(dune)
# algorithm is iterative

NMDS # gives information on NMDS: distance measure, stress (should be low)
# stress of >= 0.2 = be suspicious, stress >=0.3 indicates that ordination is arbitrary
# increase Dimensions if k is too high
ordiplot(NMDS, type = "t") #"t" = text


# if we have time:
# distance measure can be changed (default is Bray-Curtis): see 
?vegdist # some recommendations there
NMDS2 = metaMDS(dune, distance="euclidean")
NMDS2 
ordiplot(NMDS2, type = "t")
```

::: callout-caution
```{r}
# Why we should be careful when interpreting patterns in ordination plots
set.seed(123)

random = data.frame(pollution = rnorm(30),
                    temperature = rnorm(30),
                    moisture = rnorm(30),
                    tourists = rnorm(30),
                    wind = rnorm(30),
                    dogs = rnorm(30))
head(random)
pca = prcomp(random, scale = T)
biplot(pca)
summary(pca) # similar variance on all axes
```
:::

## Constrained

```{r}
# 2 multivariate datasets (abundances + environment)


## RDA
str(dune) # species composition
data("dune.env")
str(dune.env) # environmental variables

RDA = rda(dune ~ as.numeric(Manure) + as.numeric(Moisture), 
         data = dune.env)
plot(RDA)

summary(RDA)
# important part at the top
# variance explained by the two variables = prop constrained = 37.09%
# how much is explained by each RDA = see importance of components prop explained
# PCs are the unconstrained axes

# species scores = coordinates of species in the plot
# site scores = coordinates of sites in the plot
# biplot scores = coordinates of environmental variable vectors


barplot(summary(RDA)$cont$importance[2, ],  las = 2,
        col = c(rep ('red', 2), 
                rep ('black', length(summary(RDA)$cont$importance[2, ])-2)),
        ylab="proportion of variance explained") # displays % of variance explained by PCs

```

## Clustering

```{r}
# hierarchical clustering: 

library(cluster) # clustering
library(ape) # phylogenetic analyses, here to get pretty dendrogram

# example for distance matrix
dist(iris[1:3, 1:4]) # creates a distance matrix (comparison of all possible sample pairs), 
# default method ="euclidean", but can be changed

# get Hierarchical Clustering
hc = hclust(dist(iris[, 1:4]))
plot(hc)

# for colors use package ape
plot(as.phylo(hc), tip.color = as.numeric(iris$Species)) # as.phylo converts object type "hcclust" into object type "phylo"
# change plotting type:
plot(as.phylo(hc), tip.color = as.numeric(iris$Species), type = "fan")



# lets try another clustering algorithm
data(animals)
str(animals)

# Agglomerative Nesting 
aa <- agnes(animals)
plot(aa, which.plots = 2) #which.plots: plots only plot 2
# first is banner plot...



### non-hierarchical
# kmeans 

set.seed(123) # choice of first k centers is random and depends on (random) seed
cl = kmeans(iris[, 1:4], centers = 3) # centers = number of clusters to be generated

cl$cluster
as.numeric(iris$Species)


# without the same seed you may have to exchange cluster 2 and 3 to be able to compare assignment to species with real species in the plot
temp = cl$cluster
# temp[cl$cluster==2] = 3
# temp[cl$cluster==3] = 2

temp
as.numeric(iris$Species)

# original species
pairs(iris[, 1:4], col = as.numeric(iris$Species)) 

# species found by cluster
pairs(iris[, 1:4], col = temp)

# display samples that have been assigned to the wrong species
same = as.numeric(iris$Species) == temp
pairs(iris[, 1:4], col = as.numeric(same) + 1) 
palette()
```
