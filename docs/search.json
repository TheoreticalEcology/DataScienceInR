[
  {
    "path": "index.html",
    "id": "webexercises",
    "chapter": "Webexercises",
    "heading": "Webexercises",
    "text": "Web Exercise template created #PsyTeachR team University Glasgow, based ideas Software Carpentry. template shows instructors can easily create interactive web documents students can use self-guided learning.webexercises package provides number functions use inline R code code chunk options create HTML widgets (text boxes, pull menus, buttons reveal hidden content). Examples given next. Render book see work.NOTE: use widgets compiled HTML files, need JavaScript-enabled browser.",
    "code": ""
  },
  {
    "path": "index.html",
    "id": "example-questions",
    "chapter": "Webexercises",
    "heading": "0.1 Example Questions",
    "text": "functions optimised used inline r code, can also use code chunks setting chunk option results = 'asis' using cat() display result widget.function loads package already computer? install.packageinstall.packageslibrarylibraries",
    "code": "\n# echo = FALSE, results = 'asis'\nopts <- c(\"install.package\", \n            \"install.packages\", \n            answer = \"library\", \n            \"libraries\")\n\nq1 <- mcq(opts)\n\ncat(\"What function loads a package that is already on your computer?\", q1)"
  },
  {
    "path": "index.html",
    "id": "fill-in-the-blanks-fitb",
    "chapter": "Webexercises",
    "heading": "0.1.1 Fill-In-The-Blanks (fitb())",
    "text": "Create fill---blank questions using fitb(), providing answer first argument.2 + 2 can also create questions dynamically, using variables R session.square root 49 : blanks case-sensitive; care case, use argument ignore_case = TRUE.letter D? want ignore differences whitespace use, use argument ignore_ws = TRUE (default) include spaces answer anywhere acceptable.load tidyverse package? can set one possible correct answer setting answers vector.Type vowel: can use regular expressions test answers complex rules.Type 3 letters: ",
    "code": ""
  },
  {
    "path": "index.html",
    "id": "multiple-choice-mcq",
    "chapter": "Webexercises",
    "heading": "0.1.2 Multiple Choice (mcq())",
    "text": "\"Never gonna give , never gonna: let goturn downrun awaylet \"\"bless rainsguess rainssense rain Africa\" -Toto",
    "code": ""
  },
  {
    "path": "index.html",
    "id": "true-or-false-torf",
    "chapter": "Webexercises",
    "heading": "0.1.3 True or False (torf())",
    "text": "True False? can permute values vector using sample(). TRUEFALSE",
    "code": ""
  },
  {
    "path": "index.html",
    "id": "longer-mcqs-longmcq",
    "chapter": "Webexercises",
    "heading": "0.1.4 Longer MCQs (longmcq())",
    "text": "answers long, sometimes drop-select box gets formatted oddly. can use longmcq() deal . Since answers long, probably best set options inside R chunk echo=FALSE.p-value?true 95% confidence interval mean?",
    "code": ""
  },
  {
    "path": "index.html",
    "id": "checked-sections",
    "chapter": "Webexercises",
    "heading": "0.2 Checked sections",
    "text": "Create sections class webex-check add button hides feedback pressed. Add class webex-box draw box around section (use styles).going learn lot: TRUEFALSE",
    "code": ""
  },
  {
    "path": "index.html",
    "id": "hidden-solutions-and-hints",
    "chapter": "Webexercises",
    "heading": "0.3 Hidden solutions and hints",
    "text": "can fence solution area hidden behind button using hide() solution unhide() , inline R code. Pass text want appear button hide() function.solution RMarkdown code chunk, instead using hide() unhide(), simply set webex.hide chunk option TRUE, set string wish display button.Recreate scatterplot , using built-cars dataset.See documentation plot() (?plot)",
    "code": "\nplot(cars$speed, cars$dist)"
  },
  {
    "objectID": "1A-Exercise.html#setting-up-the-working-environment-in-rstudio",
    "href": "1A-Exercise.html#setting-up-the-working-environment-in-rstudio",
    "title": "Exercise - R basics",
    "section": "Setting up the working environment in RStudio",
    "text": "Setting up the working environment in RStudio\nYour first task is to open RStudio and create a new project for the course.\n\nClick the ‘File’ button in the menu, then ‘New Project’ (or the second icon in the bar below the menu “Create a project”).\nClick “New Directory”.\nClick “New Project”.\nType in the name of the directory to store your project, e.g. “IntroStatsR”.\n“Browse” to the folder on your computer where you want to have your project created.\nClick the “Create Project” button.\n\n\n\n\n\n\nFor all exercises during this week, use this project! You can open it via the file system as follows (please try this out now):\n\n(Exit RStudio).\nNavigate to the directory where you created your project.\nDouble click on the “IntroStatsR.Rproj” file in that directory.\n\nYou should now be back to RStudio in your project.\nIn the directory of the R project, generate a folder “scripts” and a folder “data”. You can do this either in the file directory or in RStudio. For the latter:\n\nGo to the “Files” panel in R Studio (bottom right panel).\nClick the icon “New Folder” in the upper left corner.\nEnter the folder name.\nThe new folder is now visible in your project directory.\n\nThe idea is that you will create an R script for each exercise and save all these files in the scripts folder. You can do this as follows:\n\nClick the “File” button in the menu, then “New File” and “R Script” (or the first icon in the bar below the menu and then “R Script” in the dropdown menu).\nClick the “File” button in the menu, then “Save” (or the “Save” icon in the menu).\nNavigate to your scripts folder.\nEnter the file name, e.g. “Exercise_01.R”.\nSave the file."
  },
  {
    "objectID": "1A-Exercise.html#a-few-hints-before-you-can-start",
    "href": "1A-Exercise.html#a-few-hints-before-you-can-start",
    "title": "Exercise - R basics",
    "section": "A few hints before you can start",
    "text": "A few hints before you can start\nRemember the different ways of running code:\n\nclick the “Run” button in the top right corner of the top left panel (code editor) OR\nhit “Ctrl”+“Enter” (MAC: “Cmd”+“Return”)\n\nRStudio will then run\n\nthe code that is currently marked OR\nthe line of code where the text cursor currently is (simply click into that line)\n\nIf you face any problems with executing the code, check the following:\n\nall brackets closed?\ncapital letters instead of small letters?\ncomma is missing?\nif RStudio shows red attention signs (next to the code line number), take it seriously\ndo you see a “+” (instead of a “&gt;”) in the console? stop executions with “esc” key and then try again.\n\nHave a look at the shortcuts by clicking “Tools” and than “Keybord Shortcuts Help”!!"
  },
  {
    "objectID": "1A-Exercise.html#basic-data-structures-in-r",
    "href": "1A-Exercise.html#basic-data-structures-in-r",
    "title": "Exercise - R basics",
    "section": "Basic data structures in R",
    "text": "Basic data structures in R\nBefore we work with real data, we should first recap important data structures in R\nA single value (type does not matter) is called a scalar (it is just one value):\n\na = 5\nprint(a)\n## [1] 5\n\nthis_letter = \"A\"\nprint(this_letter)\n## [1] \"A\"\n\n\n\n&lt;- and = are assignment operators, they are equivalent and are used to assign values, data, or objects to a variable.\nIn R you can use any type of name for a variable, you can even mix numbers and dots in the name: test5 or test.5, but there is one restriction, no special symbols (as they are usually operators or functions) and a name cannot start with a number, for example 5test will throw an error.\nHowever, usually we want to assign several values to a variable. For example, a dataset consists of several columns (=variables). We can use the function c(...) to connect (or concatenate) several values:\n\nage = c(20, 50, 30, 70)\nprint(age)\n## [1] 20 50 30 70\nnames = c(\"Anna\", \"Daniel\", \"Martin\", \"Laura\")\nprint(names)\n## [1] \"Anna\"   \"Daniel\" \"Martin\" \"Laura\"\n\n\nVectors\n\n\nYou can only concatenate values from the same data type! If they are different, all will be casted to the same data type!\n\nprint(c(\"Age\", 5, TRUE))\n## [1] \"Age\"  \"5\"    \"TRUE\"\n\nThe c(...) function returns a vector which is a one-dimensional array. You can access elements of the vector by using the square brackets [which_element]:\n\nage[2] # second element\n## [1] 50\nage[1] # first element\n## [1] 20\n\nThis is known as indexing. And there are a few tricks:\n\nUse [-n] to return all elements except for n:\n\nage[-2] # return all except for the second element\n## [1] 20 30 70\n\nUse another vector to return several elements at once:\n\nage[c(1, 3)] # return first and third elements\n## [1] 20 30\nage[-c(1,3)] # return all elements except for first and third elements\n## [1] 50 70\n\nUse &lt;- or = to re-assign/change elements in your vector\n\nage[2] = 99\nprint(age)\n## [1] 20 99 30 70\n\n\n\n\nThe : operator in R is not the division operator. It actually creates a range of integer values with start:end:\n\n1:5\n## [1] 1 2 3 4 5\n\nWhich is really useful for indexing:\n\nage[1:3]\n## [1] 20 99 30\n\n\n\nMatrix\nUsually a dataset consist not of only one variable/vector but of several variables (columns) and observations (rows), for example:\n\nage = c(20, 30, 32, 40)\nweight = c(60, 70, 72, 80)\n\nwe can use higher order data structures to combine these variables in a two dimensional array (like we would, for example, do in excel) using the matrix(...) function:\n\ndataset = matrix(NA, 4, 2)\ndataset # empty dataset\n##      [,1] [,2]\n## [1,]   NA   NA\n## [2,]   NA   NA\n## [3,]   NA   NA\n## [4,]   NA   NA\ndataset[,1] = age\ndataset[,2] = weight\ndataset\n##      [,1] [,2]\n## [1,]   20   60\n## [2,]   30   70\n## [3,]   32   72\n## [4,]   40   80\n\nSimilar to a vector we can index certain elements in the matrix or at the same time entire rows or columns. Since is has now two dimensions, we change [i] to [row_i, col_j]. The first argument specifies which row and the second argument which column should be returned. There are again a few handy tricks, above we left the rows empty (dataset[,1]) which will R interpret as “use all rows”, in that way we can print/return entire columns or rows:\n\ndataset[,1] # first column\n## [1] 20 30 32 40\ndataset[1,] # first row\n## [1] 20 60\n\n\n\nDon’t worry, you don’t have to create your own data sets like we did in this section. When you import your data into R, it is automatically returned as a matrix (or as data.frame, see below).\nA limitation of the matrix() is that is can only consist of one data type (like the vectors), if we mix the data types, all will be cast to the same data type:\n\ncbind(age, names)\n##      age  names   \n## [1,] \"20\" \"Anna\"  \n## [2,] \"30\" \"Daniel\"\n## [3,] \"32\" \"Martin\"\n## [4,] \"40\" \"Laura\"\n\n\n\ncbind() is a function that combines columns (“column binds”), it can be used as a shortcut to create a matrix from several vectors. Another important command is rbind(...) which combines vectors (or matrices) over their rows:\n\nrbind(age, names)\n##       [,1]   [,2]     [,3]     [,4]   \n## age   \"20\"   \"30\"     \"32\"     \"40\"   \n## names \"Anna\" \"Daniel\" \"Martin\" \"Laura\"\n\n\n\nData.frames\nThe data.frame() can handle variables with different data types. Data.frames are similar to matrices, they are two dimensional and the indexing is the same:\n\ndf = data.frame(age, names, weight)\ndf\n##   age  names weight\n## 1  20   Anna     60\n## 2  30 Daniel     70\n## 3  32 Martin     72\n## 4  40  Laura     80\nstr(df)\n## 'data.frame':    4 obs. of  3 variables:\n##  $ age   : num  20 30 32 40\n##  $ names : chr  \"Anna\" \"Daniel\" \"Martin\" \"Laura\"\n##  $ weight: num  60 70 72 80\n\n(we will talk below more about data.frames)"
  },
  {
    "objectID": "1A-Exercise.html#getting-an-overview-of-a-dataset",
    "href": "1A-Exercise.html#getting-an-overview-of-a-dataset",
    "title": "Exercise - R basics",
    "section": "Getting an overview of a dataset",
    "text": "Getting an overview of a dataset\nWe work with the airquality dataset:\n\ndat = airquality\n\n\n\nSeveral example datasets are already available in R. The airquality dataset with daily air quality measurements (see ?airquality). Another famous dataset is the iris dataset with flower trait measurements for three species (see ?iris).\nCopy the code into your code editor and execute it.\nBefore working with a dataset, you should always get an overview of it. Helpful functions for this are:\n\nstr()\nView()\nhead() and tail()\n\nTry out these functions and provide answers to the following questions:\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhat is the most common atomic class in the airquality dataset? integernumericcharacterfactor\nHow many rows does the dataset have? \nWhat is the last value in the column “Temp”? \n\n\nTo see all this, run\n\ndat = airquality\nView(dat)\nstr(dat)\nhead(dat)\ntail(dat)\n\n\n\n\nHints:\n\nRun str(airquality)\nSee ?nrow or ?dim\nRun tail(airquality$Temp)\n\n\n\nClick here to see the solution\n\nWhat is the most common atomic class in the airquality dataset?\n\ninteger\nfunction str() helps to find this out\n\nHow many rows does the dataset have?\n\n153\nthis is easiest to see when using the function str(dat)\ndim(dat) or nrow(dat) give the same information\n\nWhat is the last value in the column “Temp”?\n\n68\ntail(dat) helps to find this out very fast"
  },
  {
    "objectID": "1A-Exercise.html#accessing-rows-and-columns-of-a-data-frame",
    "href": "1A-Exercise.html#accessing-rows-and-columns-of-a-data-frame",
    "title": "Exercise - R basics",
    "section": "Accessing rows and columns of a data frame",
    "text": "Accessing rows and columns of a data frame\nYou have seen how you can use squared brackets [ ] and the dollar sign $ to extract parts of your data. Some people find this confusing, so let’s repeat the basic concepts:\n\nsquared brackets are used as follows: data[rowNumber, columnNumber]\nthe dollar sign helps to extract colums with their name (good for readability): data$columnName\nthis syntax can also be used to assign new columns, simply use a new column name and the assign operator: data$newColName &lt;-)\n\n\n\n\n\n\n\nQuestion\n\n\n\nThe following lines of code assess parts of the data frame. Try out what they do and sort the code lines and their meaning:\nWhich of the following commands\n\ndat[2, ]\ndat[, 2]\ndat[, 1]\ndat$Ozone\nnew = dat[, 3] + dat[, 4]\ndat$new = dat[, 3] + dat[, 4]\ndat$NAs = NA\nNA -&gt; dat$NAs \n\nwill get you\n\nget the second row\nget column Ozone\ngenerate a new column with NA’s\ncalculate the sum of columns 3 and 4 and assign to a new column\n\n\n\n\n\nHint: Some of the code lines actually do the same; chose the preferred way in these cases.\n\n\n\n\n\n\nSolution\n\n\n\n\n\nget second row\n\ndat[2, ] is correct\ndat[, 2] gives the second column\n\nget column Ozone\n\ndat$Ozone is the best option\ndat[, 1] gives the same result, but is much harder to understand later on\n\ngenerate a new column with NA’s\n\ndat$NAs = NA is the best option\nNA -&gt; dat$NAs does the same, but the preferred syntax in R is having the new variable on the left hand side (the arrow should face to the left not right)\n\ncalculate the sum of columns 3 and 4 and assign to a new column\n\ndat$new = dat[, 3] + dat[, 4] is correct\nnew = dat[, 3] + dat[, 4] creates a new object but not a new column in the existing data frame"
  },
  {
    "objectID": "1A-Exercise.html#filtering-data",
    "href": "1A-Exercise.html#filtering-data",
    "title": "Exercise - R basics",
    "section": "Filtering data",
    "text": "Filtering data\nTo use the data, you must also be able to filter it. For example, we may be interested in hot days in July and August only. Hot days are typically defined as days with a temperature equal or &gt; 30°C (or 86°F as in the dataset here). Imagine, your colleague tried to query the data accordingly. She/he also found a mistake in each of the first 4 rows and wants to exclude these, but she/he is very new to R and made a few common errors in the following code:\n\n# Return only rows where the temperature is exactly is 86\ndat[dat$Temp = 86, ]\n\n# Return only rows where the temperature is equal or larger than 86\ndat[dat$Temp &gt;= 86]\n\n# Exclude rows 1 through 4\ndat[-1:4, ]\n\n# Return only rows for the months 7 or 8\ndat[dat$Month == 7 | 8, ]\n\n\n\n\n\n\n\nQuestion\n\n\n\nCan you fix his/her mistakes? These hints may help you:\n\nrows or columns can be excluded, if the numbers are given as negative numbers\n== means “equals”\n& means “AND”\n| means “OR” (press “AltGr”+“&lt;” to produce |, or “option”+“7” on MacOS)\nexecuting the erroneous code may help you to spot the problem\nrun parts of the code if you don’t understand what the code does\nthe last question is a bit trickier, no problem if you don’t find a solution\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThis is the corrected code:\n\n# Return only rows where the temperature is exactly is 86\ndat[dat$Temp == 86, ]\n\n# Return only rows where the temperature is equal or larger than 86\ndat[dat$Temp &gt;= 86, ]\n\n# Exclude rows 1 through 4\ndat[-(1:4), ]\n\n# Return only rows for the months 7 or 8\ndat[dat$Month == 7 | dat$Month == 8, ]\ndat[dat$Month %in% 7:8, ] # alternative expression\n\n\n\n\n\n\nThe %in% operator is useful when you want to check whether a value is inside a vector or not:\n\n5 %in% c(1, 2, 3, 4, 5)\n## [1] TRUE\n\nWe will discuss the results together.\nWhen you are finished, save your R script!"
  },
  {
    "objectID": "1A-Exercise.html#last-task---install-ecodata-package",
    "href": "1A-Exercise.html#last-task---install-ecodata-package",
    "title": "Exercise - R basics",
    "section": "Last task - Install EcoData package",
    "text": "Last task - Install EcoData package\nDuring the course, we will use some datasets that we compiled in the \\(EcoData\\) package. To access the datasets, you need to install the package from github. To do this, you will also need to install the \\(devtools\\) package.\nTry the following code to install the two packages:\n\ninstall.packages(\"devtools\")\nlibrary(devtools)\ndevtools::install_github(repo = \"TheoreticalEcology/EcoData\", \n                         dependencies = F, build_vignettes = F)\nlibrary(EcoData)\n\nRemember that you have to install a package only once. If you open R Studio the next time, it is enough to run library(EcoData).\n\nAlternative ways to get EcoData\nIf the installation didn’t work, download the package file manually from\nhttps://github.com/TheoreticalEcology/ecodata/releases/download/v0.2.1/EcoData_0.2.1.tar.gz\nStore the file on your computer in the same folder where you created your R project. Then run the following code:\n\ninstall.packages(\"EcoData_0.2.1.tar.gz\", \n                 repos = NULL, type = \"source\")\nlibrary(EcoData)\n\nIf this wasn’t successful either, you can download the combined datasets from elearning (see Organisation and every-day material)\nStore the file on your computer in the same folder where you created your R project. Then run the following code:\n\nload(\"EcoData.Rdata\")\n\n(Note that you will not be able to access the dataset descriptions when you use this option)."
  },
  {
    "objectID": "1A-Exercise.html#bonus---advanced-programming",
    "href": "1A-Exercise.html#bonus---advanced-programming",
    "title": "Exercise - R basics",
    "section": "Bonus - Advanced programming",
    "text": "Bonus - Advanced programming\nUntil now we have only learned how to use functions and indexing of data structures. But what are functions?\n\nFunctions\nA functions are self contained blocks of code that do something, for example, the average of a vector is given by:\n\\[\nAverage = \\frac{1}{N} \\sum_{i=1}^N x_i\n\\]\nIn R we can easily calculate the sum over a vector by using the function sum():\n\nvalues = 1:10\nprint(values)\n##  [1]  1  2  3  4  5  6  7  8  9 10\n\n# Average \nsum(values)/length(values)\n## [1] 5.5\n\nTo do that now more easily and in a comprehensive way for many different variables, we can define a function to calculate the mean:\n\naverage = function(x) {\n  average = sum(x)/length(x)\n  return(average)\n}\naverage(values)\n## [1] 5.5\n\nA function consists of: - An expressive name - Arguments function(arg1, arg2, arg3), the arguments can be used to pass the data to the function, or to change the behaviour of the function (see below) - A function body, inside curly brackets { } where the actual magic happens - return(...) what should be returned from the function\nThe advantages: - you can compress big code blocks within one function call - reproducibility, we avoid writing the same code again and again, if we want to change the way how we calculate the average, we have to change it only in one place - clarity, the name of the function can give us a hint about what the function is doing\nArguments\nArguments can be either used to pass data to the function or to change the behaviour of the function. Moreover, you can set default values to the function. If arguments have default values, they do not have to be specified (specifiying means that we have to fill this argument):\n\n# Should NAs be removed or not\naverage = function(x, remove_na) {\n  if(!remove_na) {\n    average = sum(x)/length(x)\n  } else {\n    average = sum(x, na.rm = TRUE)/length(x[complete.cases(x)])\n  }\n  return(average)\n}\n\nvalues = c(5, 4, 3, NA, 5, 2)\n\n# no default option for remove_na, we have to specify it!\naverage(values, remove_na = TRUE)\n## [1] 3.8\n\n# In this case, it is better to set a default option for remova_na:\naverage = function(x, remove_na = TRUE) {\n  if(!remove_na) {\n    average = sum(x)/length(x)\n  } else {\n    average = sum(x, na.rm = TRUE)/length(x[complete.cases(x)])\n  }\n  return(average)\n}\n\naverage(values)\n## [1] 3.8\n\n\n\nif(condition) {  } else { } the if/else statements runs code if a certain condition is true or not. If the condition is true, the first code block {  } is run, if it is false, the second (after the else) is run:\n\nvalues = 1:5\nif(length(values) == 5) {\n  print(\"This vector has length 5\")\n} else {\n  print(\"This vector has not length 5\")\n}\n## [1] \"This vector has length 5\"\n\nArguments are matched by the name or, if names are not specified, by the order:\nfunc(x1, x2, x3) will be interpreted as func(arg1 = x1, arg2 = x2, arg3 = x3)\nBut be careful, if you are unsure about the correct order, you should pass them by their name (func(arg1 = x1, arg2 = x2, arg3 = x3))\n\n\nLoops\nLoops are another important code structure. Example: We want to go over all values of a vector, calculate the square root of it, and overwrite the old value with the new value:\n\nvalues = c(20, 33, 25, 16)\nvalues[1] = sqrt(values[1])\nvalues[2] = sqrt(values[2])\nvalues[3] = sqrt(values[3])\nvalues[4] = sqrt(values[4])\n\nNow what should we do if we have thousands of observations? Loops are the solution! We can use them to automatically “run” a specific vector and then do something with it (well it sounds cryptic but it is actually quite easy):\n\nfor(i in 1:4) { # i in 1:4 means that i should be 1, 2, 3, and 4\n  print(i)\n}\n## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n\n# Let's use it to automatize the previous computation:\nfor(i in 1:4) {\n  values[i] = sqrt(values[i])\n}\nvalues\n## [1] 2.114743 2.396782 2.236068 2.000000\n\n# Even better: do not hardcode the length of the vector:\nfor(i in 1:length(values)) {\n  values[i] = sqrt(values[i])\n}\nvalues\n## [1] 1.454215 1.548154 1.495349 1.414214\n\nOur code will now always work, even if we change the length of the values variable!\n\n\n\n\n\n\nBonus Question\n\n\n\nWrite functions for:\n\nCalculate the sum for all values in a matrix given by (we want to write our own implementation of the internal sum(...) function):\n\nmy_matrix = matrix(1:200, 20, 10)\n\nUse the internal sum(...) function to check whether your function is correct!\nExtend the function with arguments that specify that the sum should be calculate over rows, columns, or both (if we calculate the sum over rows or columns, then a vector with n sums for n rows or n columns should be returned).\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nsum_matrix function\n\n\n\nsum_matrix = function(X) {\n\n  n_row = nrow(X)\n  n_col = ncol(X)\n  result = 0\n  for(i in 1:n_row) {\n    for(j in 1:n_col) {\n      result = result + X[i,j]\n    }\n  }\n  return(result)\n}\n\n\nsum_matrix_extended function\n\n\n  sum_matrix_extended = function(X, which = \"both\") {\n  if(which == \"both\") {\n    result = sum_matrix(X)\n  } else if(which == \"row\") {\n    result = apply(X, 1, sum)\n  } else if(which == \"row\") {\n    result = apply(X, 2, sum)\n  }\n  return(result)\n}\n\nThe apply(...) function can be used to automatically loop over rows (MARGIN=1) or columns (MARGIN=2) and apply a function on each element (rows or columns) which can be specified via apply(data, MARGIN = 1, FUN = sum)"
  },
  {
    "objectID": "4A-Exercise.html#analyzing-the-regrowth-dataset",
    "href": "4A-Exercise.html#analyzing-the-regrowth-dataset",
    "title": "10  Exercises",
    "section": "10.1 Analyzing the “regrowth” dataset",
    "text": "10.1 Analyzing the “regrowth” dataset\n\n\n\n\n\n\nWarning\n\n\n\nImagine you have a garden with some fruit trees and you were thinking of adding some berry bushes between them. However, you don’t want them to suffer from malnutrition so you want to estimate the volume of root biomass as a function of the fruit biomass.\nCarry out the following tasks\n\nPerform a simple linear regression for the influence of fruit biomass on root biomass.\nVisualize the data and add the regression line to the plot.\n\nYou will need the following functions:\n\nlm()\nsummary()\nplot()\nabline()\n\n\n10.1.1 Question\nYou have performed a simple linear regression for the influence of fruit biomass on root biomass.\nWhich of the following statements are correct?\n\n\n\n\n\nClick here to see the solution\n\n\n10.1.2 Solution\nThis is the code that you need to interpret the results.\n\nlibrary(EcoData)\n# simple linear regression\nfit &lt;- lm(Root ~ Fruit, data = regrowth)\n\n# check summary for regression coefficient and p-value\nsummary(fit)\n## \n## Call:\n## lm(formula = Root ~ Fruit, data = regrowth)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -1.25105 -0.69970 -0.01755  0.66982  1.63933 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept) 4.184256   0.337987  12.380  6.6e-15 ***\n## Fruit       0.050444   0.005264   9.584  1.1e-11 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 0.8111 on 38 degrees of freedom\n## Multiple R-squared:  0.7073, Adjusted R-squared:  0.6996 \n## F-statistic: 91.84 on 1 and 38 DF,  p-value: 1.099e-11\n\n# plot root explained by fruit biomass\nplot(Root ~ Fruit, data = regrowth, \n     ylab = \"Root biomass in cubic meters\",\n     xlab = \"Fruit biomass in g\")\n\nabline(fit) # add regression line\nabline(v = 70, col = \"purple\") # add line at x value (here fruit biomass of 70g)\nabline(h = 4.184256 + 0.050444*70, col = \"brown\") # add line at y value according to x = 70 using the intercept and regression coefficient of x"
  },
  {
    "objectID": "4A-Exercise.html#analyzing-the-birdabundance-dataset",
    "href": "4A-Exercise.html#analyzing-the-birdabundance-dataset",
    "title": "10  Exercises",
    "section": "10.2 Analyzing the “birdabundance” dataset",
    "text": "10.2 Analyzing the “birdabundance” dataset\nThe dataset provides bird abundances in forest fragments with different characteristics in Australia. We want to look at the relationship of the variables “abundance”, “distance” and “grazing”.\n\n\n\n\n\n\nQuestions\n\n\n\nFirst, answer the following questions on elearning-extern (Q 2-4):\n\nWhat is the most reasonable research question regarding these variables?\nWhat is the response variable?\nWhat is the predictor variable?\n\nThen, perform the following tasks:\n\nFit a simple linear regression relating the response variable to the categorical predictor (that is the one with five levels, make sure that it is indeed a factor using as.factor())\nApply an ANOVA to your model.\n\nYou may need the following functions:\n\nlm()\nsummary()\nanova()\n\nUse your results to chose the correct statement(s) on elearning-extern (Q5).\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nA reasonable research question is how abundance is influenced by distance and/or grazing. Here, the response variable is abundance, while the predictors are distance and/or grazing.\nThis is the code that you need to interpret the results.\n\n# change variable from integer to factor\nbirdabundance$GRAZE &lt;- as.factor(birdabundance$GRAZE) \nfit &lt;- lm(ABUND ~ GRAZE, data = birdabundance)\nsummary(fit)\n## \n## Call:\n## lm(formula = ABUND ~ GRAZE, data = birdabundance)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -18.3867  -4.1159   0.0269   5.1484  16.4133 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)   28.623      2.086  13.723  &lt; 2e-16 ***\n## GRAZE2        -6.673      3.379  -1.975   0.0537 .  \n## GRAZE3        -7.336      2.850  -2.574   0.0130 *  \n## GRAZE4        -8.052      3.526  -2.284   0.0266 *  \n## GRAZE5       -22.331      2.950  -7.571 6.85e-10 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 7.52 on 51 degrees of freedom\n## Multiple R-squared:  0.5449, Adjusted R-squared:  0.5092 \n## F-statistic: 15.27 on 4 and 51 DF,  p-value: 2.846e-08\n\n# anova to check global effect of the factor grazing intensity\nanova(fit)\n## Analysis of Variance Table\n## \n## Response: ABUND\n##           Df Sum Sq Mean Sq F value    Pr(&gt;F)    \n## GRAZE      4 3453.7  863.42  15.267 2.846e-08 ***\n## Residuals 51 2884.2   56.55                      \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n# boxplot\nplot(ABUND ~ GRAZE, data = birdabundance)"
  },
  {
    "objectID": "4A-Exercise.html#model-validation-residual-checks",
    "href": "4A-Exercise.html#model-validation-residual-checks",
    "title": "10  Exercises",
    "section": "10.3 Model validation: Residual checks",
    "text": "10.3 Model validation: Residual checks\nNow, we will have a closer look at model diagnostics and residual checks in particular. Of course, we should have done this for all models above as well (we simply didn’t do this because of time restrictions). So remember that you always have to validate your model, if you want to be sure that your conclusions are correct.\nFor this exercise, you can prepare a dataset yourself called “dat” with the variables “x” and “y”. Simply copy the following code to generate the data:\n\nset.seed(234)\nx = rnorm(40, mean = 10, sd = 5)\ny = 10 - 2*x + 0.9 * x^2 + rnorm(40, mean=5, sd = 20)\ndat &lt;- data.frame(x, y)\nhead(dat)\n##           x          y\n## 1 13.303849 152.093910\n## 2 -0.264915   6.831275\n## 3  2.503970  45.207691\n## 4 17.356166 240.274237\n## 5 17.295693 240.917066\n## 6 10.700695 117.691234\n\nPerform the following tasks:\n\n\n\n\n\n\nWarning\n\n\n\n\nFit a simple linear regression.\nCheck the residuals.\nPerform another simple linear regression with a modified formula, if needed.\nCreate a scatter plot of the data and add a regression line for the first fit in black and one for the second fit in red. The second model cannot be plotted with the abline() function. Use the following code instead:\n\n\nlines(sort(x), predict(fit2, newdata = data.frame(x = sort(x))), col = \"red\")\n\nYou may also need the following functions:\n\nlm()\nsummary()\npar(mfrow = c(2, 2))\nplot()\nabline()\n\nUse your results to answer the following questions:\n\nWhat pattern do the residuals of the first regression model show when plotted against the fitted values?\nWhat do you have to do to improve your first regression model?\nIdentify the correct statement(s) about the residuals of the modified model.\n\n\n\n\n\nClick here to see the solution\n\n\nset.seed(234)\nx = rnorm(40, mean = 10, sd = 5)\ny = 10 - 2*x + 0.9 * x^2 + rnorm(40, mean=5, sd = 20)\ndat &lt;- data.frame(x, y)\n\n# simple linear regression\nfit &lt;- lm(y ~ x, dat)\n\n# check residuals\nop = par(mfrow=c(2,2))\nplot(fit) # residuals show a parabolic relationship (see first plot)  -&gt; to improve, fit a quadratic relationship\n\n\n\npar(op)\n\n# scatter plot\nplot(y ~ x, data = dat)\nabline(fit)\n\n\n\n\nsummary(fit) # significantly positively correlated, but this doesn't tell the full story because the residuals are not okay\n## \n## Call:\n## lm(formula = y ~ x, data = dat)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -39.884 -22.208  -4.948  10.602 118.164 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept)   -8.459     10.973  -0.771    0.446    \n## x             11.465      1.019  11.248 1.18e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 32.11 on 38 degrees of freedom\n## Multiple R-squared:  0.769,  Adjusted R-squared:  0.763 \n## F-statistic: 126.5 on 1 and 38 DF,  p-value: 1.176e-13\n\n# improved regression model\nfit2 = lm(y ~ x + I(x^2), dat)\n\n# check residuals\nop = par(mfrow=c(2,2))\nplot(fit2) # no pattern in residuals anymore (first plot) -&gt; fit is fine\n\n\n\npar(op)\n\n# scatter plot\nplot(y ~ x, data = dat)\nabline(fit)\nlines(sort(x), predict(fit2, newdata = data.frame(x = sort(x))), col = \"red\")\n\n\n\n\n\nsummary(fit2) # significantly negatively correlated, trustworthy now, because residuals are sufficiently uniformly distributed (first plot in plot(fit2))\n## \n## Call:\n## lm(formula = y ~ x + I(x^2), data = dat)\n## \n## Residuals:\n##     Min      1Q  Median      3Q     Max \n## -33.174 -11.444   0.938  10.164  40.666 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(&gt;|t|)    \n## (Intercept) 17.87505    6.00812   2.975  0.00513 ** \n## x           -1.10100    1.27706  -0.862  0.39417    \n## I(x^2)       0.80752    0.07526  10.730 6.49e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 16.05 on 37 degrees of freedom\n## Multiple R-squared:  0.9438, Adjusted R-squared:  0.9408 \n## F-statistic: 310.9 on 2 and 37 DF,  p-value: &lt; 2.2e-16"
  }
]