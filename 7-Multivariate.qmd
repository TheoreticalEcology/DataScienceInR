---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r, include=FALSE}
set.seed(42)
```

# Multivariate Statistics

## Classroom demo

```{r}

# Part 3
# Multivariate statistics



# Method 1: unconstrained ------------------------------------------------



## PCA
# we use the same dataset of flower characteristics of three species of iris
pairs(iris, col = iris$Species)

head(iris)
pca = prcomp(iris[, 1:4], scale = T) # always set scale = T
# when data is very skewed --> better transform e.g. log

summary(pca)
# standard deviation^2 is variance!!!
# cum prop of PC2 is the variance that is visualized in a biplot


# plot the result
# absolute variance of each component
plot(pca) # see row1 of the summary(pca): (sd)^2 = variance

# rel variance of each component
barplot(summary(pca)$importance[2, ], 
        ylab="proportion of variance explained") # displays % of variance explained by PCs

# Biplot
biplot(pca) # displays PC1 and PC2 AND rotation (vectors) of the different variables AND observations




## distance-based approach: NMDS

library(vegan)
?vegan

# community dataset for plants in dunes (included in vegan package):

data("dune")
str(dune) # display structure of the dataset
?dune
summary(dune) # display summary of the dataset (summary statistics for each variable)

NMDS = metaMDS(dune)
# algorithm is iterative

NMDS # gives information on NMDS: distance measure, stress (should be low)
# stress of >= 0.2 = be suspicious, stress >=0.3 indicates that ordination is arbitrary
# in crease Dimensions if k is too high
ordiplot(NMDS, type = "t") #"t" = text


# if we have time:
# distance measure can be changed (default is Bray-Curtis): see 
?vegdist # some recommendations there
NMDS2 = metaMDS(dune, distance="euclidean")
NMDS2 
ordiplot(NMDS2, type = "t")




# Method 2: constrained  ------------------------------------------------


# 2 multivariate datasets (abundances + environment)


## RDA
str(dune) # species composition
data("dune.env")
str(dune.env) # environmental variables

RDA = rda(dune ~ as.numeric(Manure) + as.numeric(Moisture), 
         data = dune.env)
plot(RDA)

summary(RDA)
# important part at the top
# variance explained by the two variables = prop constrained = 37.09%
# how much is explained by each RDA = see importance of components prop explained
# PCs are the unconstrained axes

# species scores = coordinates of species in the plot
# site scores = coordinates of sites in the plot
# biplot scores = coordinates of environmental variable vectors


barplot(summary(RDA)$cont$importance[2, ],  las = 2,
        col = c(rep ('red', 2), 
                rep ('black', length(summary(RDA)$cont$importance[2, ])-2)),
        ylab="proportion of variance explained") # displays % of variance explained by PCs








# Method 3: Clustering ---------------------------------------------------

# hierarchical clustering: 

library(cluster) # clustering
library(ape) # phylogenetic analyses, here to get pretty dendrogram

# example for distance matrix
dist(iris[1:3, 1:4]) # creates a distance matrix (comparison of all possible sample pairs), 
# default method ="euclidean", but can be changed

# get Hierarchical Clustering
hc = hclust(dist(iris[, 1:4]))
plot(hc)

# for colors use package ape
plot(as.phylo(hc), tip.color = as.numeric(iris$Species)) # as.phylo converts object type "hcclust" into object type "phylo"
# change plotting type:
plot(as.phylo(hc), tip.color = as.numeric(iris$Species), type = "fan")



# lets try another clustering algorithm
data(animals)
str(animals)

# Agglomerative Nesting 
aa <- agnes(animals)
plot(aa, which.plots = 2) #which.plots: plots only plot 2
# first is banner plot...



### non-hierarchical
# kmeans 

set.seed(123) # choice of first k centers is random and depends on (random) seed
cl = kmeans(iris[, 1:4], centers = 3) # centers = number of clusters to be generated

cl$cluster
as.numeric(iris$Species)


# without the same seed you may have to exchange cluster 2 and 3 to be able to compare assignment to species with real species in the plot
temp = cl$cluster
# temp[cl$cluster==2] = 3
# temp[cl$cluster==3] = 2

temp
as.numeric(iris$Species)

# original species
pairs(iris[, 1:4], col = as.numeric(iris$Species)) 

# species found by cluster
pairs(iris[, 1:4], col = temp)

# display samples that have been assigned to the wrong species
same = as.numeric(iris$Species) == temp
pairs(iris[, 1:4], col = as.numeric(same) + 1) 
palette()


# HERE EXERCISE WITH BREAKOUT SESSION




# Attention ---------------------------------------------------------------



##### type (or copy) the following while students work on their exercise
# Why we should be careful when interpreting patterns in ordination plots

set.seed(123)

random = data.frame(pollution = rnorm(30),
                    temperature = rnorm(30),
                    moisture = rnorm(30),
                    tourists = rnorm(30),
                    wind = rnorm(30),
                    dogs = rnorm(30))
head(random)
pca = prcomp(random, scale = T)
biplot(pca)

```


## Exercises


```{r load data and libraries, echo=FALSE, message=FALSE, warning=FALSE}
dat = read.table(file = "http://evol.bio.lmu.de/_statgen/Multivariate/11SS/RIKZGroups.txt", header = T)
library(vegan)
library(cluster)
library(ape)
library(ggfortify)
```

In this exercise you will practice analyzing multivariate datasets using:

 * ordination methods which explore higher-order correlations among variables and similarities between observations
 * clustering methods which aggregate individual observations into clusters.

#### Useful functions for multivariate data analyses
  
*pairs()* - create pairplot (plot all variables against each other)  
*prcomp()* - calculate PCA  
*plot(pca_object)* - plot variance explained by PC axes  
*biplot()* - plot PCA  
*metaMDS()* - calculate NMDS  
*ordiplot(nmds_object)* - plot NMDS   
*rda()* - calculate RDA  
*plot(rda_object)* - plot RDA  
*dist()* - create distance matrix  
*hclust()* - perform hierarchical clustering; apply to distance matrix  
*plot(as.phylo(hc_object))* - plot dendrogram from hclust output  
*agnes()* - another clustering algorithm  
*kmeans()* - perform kmeans non-hierarchical clustering; access cluster assignments using *kmeans_object$cluster*  
  
#### Background on the dataset

Marine coastal ecosystems harbor the most productive and diverse communities on Earth. However, they are extremely vulnerable to climate change and human activities (such as landclaim, pollution, recreation purposes, ...) As a consequence, the performance of this ecosystem has decreased considerably. To better understand these ecosystems, the dutch governmental institute (RIKZ: Rijksinstituut voor Kust en Zee) started a research project on sandy beaches to investigate the relationship between environmental factors and how they might affect benthic fauna. *(from the LMU and Zuur, Ieno, Smith (2007), Chapter 12.8-12.10 and 27)*

**Question**  
We now want to use ordination methods to explore

 * the variability in environmental conditions
 * the variability in species richness

We also want to use clustering methods to define 3 environmental types and hierarchically cluster the samples with respect to their species richness.


**Dataset**  

Read in the dataset as follows:  

```{r, eval = FALSE}
dat = read.table(file = "http://evol.bio.lmu.de/_statgen/Multivariate/11SS/RIKZGroups.txt", header = T)
head(dat)
```

You already know the functions *str()* and *summary()* to get an overview of a dataset and to see which variables the dataset contains.  

 * columns 2:5 is **species richness** within four larger faunal groups
 * columns 7:16 are different **environmental variables**  

Not important for us are:

 * column 6 (week), a time stamp  
 * column 17 (sorting1), variable from the observational design 

Let's get into the analysis!  


### Unconstrained ordination (PCA)


Carry out the following analyses:

 * Make two PCAs, one for the environmental and one for the species richness data (see columns above). 
 * Name the results *pca_environment* and *pca_species*. 
 * Create a biplot for each PCA.
 * Create a barplot for the variance explained by each component. 

For example, the result for species richness should look like this:

```{r, echo = FALSE}
pca_species <- prcomp(dat[,2:5], scale = T) # conduct a principle component analysis (pca) with the assinged name "pca"

par(mfrow = c(1, 2))
biplot(pca_species, main = "PCA") # plot the results of the pca as a rotation matrix
barplot(summary(pca_species)$importance[2,1:4],
        main = "Components of species",
        ylab = "Proportion of variance explained")
par(mfrow = c(1, 1))
```

You need the following functions and the package *vegan*:

 * *prcomp()*
 * *biplot()*  
 * *barplot()*
 * *summary()*

```{r, eval = FALSE}
library(vegan)
```


**Hints**

 * Don't forget to scale the variables in the PCA.
 * In order to get the proportion of the explained variance, have a look at the summary of your analysis. *str()* shows you what the summary contains. You want to specifically look at the *importance*, here the second row contains the proportion of variance of all 4 components. So what we want to plot is: *summary(pca_species)$importance[2,1:4]*.
 * Don't forget to give your plots a title.

Now, use your results to **answer the questions on elearning-extern**.


 1. In which multivariate dataset do the first and second components explain more variance?
 2. Describe the following correlations: 
    a) salinity and humus
    b) angle1 and exposure
    c) Crustacea and NAP
    d) Polychaeta and Mollusca
 3. Which environmental variables would you choose, if you have only the resource to measure three variables?






### Clustering


#### K-means

We want to use clustering methods to define 3 environmental types. 
Use the function *kmeans()* with *centers = 3* (number of clusters to be generated). 
Remember to set a seed; the choice of the first k centers is random.


```{r, eval = FALSE}
set.seed(123) 
cl = ####
```

Compare the three clusters with the result of the PCA using the following code that uses another plotting framework called ggplot2: 

```{r, eval = FALSE}
library(ggfortify)
autoplot(pca_environment, colour = cl$cluster, size = 2, loadings = TRUE, loadings.colour = 'black',
         loadings.label = TRUE, loadings.label.size = 3, loadings.label.colour = "black")
```

The colors of the points represent the three clusters. **Answer the following question on elearning-extern**: 
How is it possible that four observations in the middle (in black if you have used the same seed) belong to a different cluster than the observations around them?



#### Hierarchical clustering

Now we want to hierarchically cluster the samples with respect to their species richness, as shown in the following plot: 

```{r clustering, echo = FALSE}
hc = hclust(dist(dat[, 2:5]))
plot(as.phylo(hc))
```
  
Create the same plot using the functions:  

 * *hclust()*   
 * *plot()* 
 * *as.phylo()*
 
Have a look at the help for *hclust()* to read what the function does and look at the examples for further help on how to use the function. Then have a look at what the function *as.phylo()* does.  

Now, color the labels using the variable *week*. You can do this using the argument "tip.color =". Choose the correct statements about the species richness and its sampling on **elearning-extern**.




